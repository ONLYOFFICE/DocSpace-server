from __future__ import annotations
from inspect import getfullargspec
import json
import pprint
import re  # noqa: F401
{{#vendorExtensions.x-py-other-imports}}
{{{.}}}
{{/vendorExtensions.x-py-other-imports}}
{{#vendorExtensions.x-py-model-imports}}
{{{.}}}
{{/vendorExtensions.x-py-model-imports}}
from typing import Union, Any, List, Set, TYPE_CHECKING, Optional, Dict
from typing_extensions import Literal, Self
from pydantic import Field
{{#allOf}}
from {{packageName}}.models.{{#lambda.snakecase}}{{{.}}}{{/lambda.snakecase}} import {{{.}}}
{{/allOf}}

class {{classname}}({{#allOf}}{{{.}}}{{^-last}}, {{/-last}}{{/allOf}}):
    """
    {{{description}}}{{^description}}{{{classname}}}{{/description}}
    """

{{#vendorExtensions.x-localVars}}
    {{name}}: {{{vendorExtensions.x-py-typing}}}
{{/vendorExtensions.x-localVars}}

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[{{^hasChildren}}Self{{/hasChildren}}{{#hasChildren}}{{#discriminator}}Union[{{#mappedModels}}{{{modelName}}}{{^-last}}, {{/-last}}{{/mappedModels}}]{{/discriminator}}{{^discriminator}}Self{{/discriminator}}{{/hasChildren}}]:
        """Create an instance of {{{classname}}} from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        {{#vendorExtensions.x-py-readonly}}
        * OpenAPI `readOnly` fields are excluded.
        {{/vendorExtensions.x-py-readonly}}
        {{#isAdditionalPropertiesTrue}}
        * Fields in `self.additional_properties` are added to the output dict.
        {{/isAdditionalPropertiesTrue}}
        """
        excluded_fields: Set[str] = set([
            {{#vendorExtensions.x-py-readonly}}
            "{{{.}}}",
            {{/vendorExtensions.x-py-readonly}}
            {{#isAdditionalPropertiesTrue}}
            "additional_properties",
            {{/isAdditionalPropertiesTrue}}
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        {{#allVars}}
        {{#isContainer}}
        {{#isArray}}
        {{#items.isArray}}
        {{^items.items.isPrimitiveType}}
        # override the default output from pydantic by calling `to_dict()` of each item in {{{name}}} (list of list)
        _items = []
        if self.{{{name}}}:
            for _item_{{{name}}} in self.{{{name}}}:
                if _item_{{{name}}}:
                    _items.append(
                         [_inner_item.to_dict() for _inner_item in _item_{{{name}}} if _inner_item is not None]
                    )
            _dict['{{{baseName}}}'] = _items
        {{/items.items.isPrimitiveType}}
        {{/items.isArray}}
        {{^items.isArray}}
        {{^items.isPrimitiveType}}
        {{^items.isEnumOrRef}}
        # override the default output from pydantic by calling `to_dict()` of each item in {{{name}}} (list)
        _items = []
        if self.{{{name}}}:
            for _item_{{{name}}} in self.{{{name}}}:
                if _item_{{{name}}}:
                    _items.append(_item_{{{name}}}.to_dict())
            _dict['{{{baseName}}}'] = _items
        {{/items.isEnumOrRef}}
        {{/items.isPrimitiveType}}
        {{/items.isArray}}
        {{/isArray}}
        {{#isMap}}
        {{#items.isArray}}
        {{^items.items.isPrimitiveType}}
        # override the default output from pydantic by calling `to_dict()` of each value in {{{name}}} (dict of array)
        _field_dict_of_array = {}
        if self.{{{name}}}:
            for _key_{{{name}}} in self.{{{name}}}:
                if self.{{{name}}}[_key_{{{name}}}] is not None:
                    _field_dict_of_array[_key_{{{name}}}] = [
                        _item.to_dict() for _item in self.{{{name}}}[_key_{{{name}}}]
                    ]
            _dict['{{{baseName}}}'] = _field_dict_of_array
        {{/items.items.isPrimitiveType}}
        {{/items.isArray}}
        {{^items.isArray}}
        {{^items.isPrimitiveType}}
        {{^items.isEnumOrRef}}
        # override the default output from pydantic by calling `to_dict()` of each value in {{{name}}} (dict)
        _field_dict = {}
        if self.{{{name}}}:
            for _key_{{{name}}} in self.{{{name}}}:
                if self.{{{name}}}[_key_{{{name}}}]:
                    _field_dict[_key_{{{name}}}] = self.{{{name}}}[_key_{{{name}}}].to_dict()
            _dict['{{{baseName}}}'] = _field_dict
        {{/items.isEnumOrRef}}
        {{/items.isPrimitiveType}}
        {{/items.isArray}}
        {{/isMap}}
        {{/isContainer}}
        {{^isContainer}}
        {{^isPrimitiveType}}
        {{^isEnumOrRef}}
        # override the default output from pydantic by calling `to_dict()` of {{{name}}}
        if self.{{{name}}}:
            _dict['{{{baseName}}}'] = self.{{{name}}}.to_dict()
        {{/isEnumOrRef}}
        {{/isPrimitiveType}}
        {{/isContainer}}
        {{/allVars}}
        {{#isAdditionalPropertiesTrue}}
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        {{/isAdditionalPropertiesTrue}}
        {{#allVars}}
        {{#isNullable}}
        # set to None if {{{name}}} (nullable) is None
        # and model_fields_set contains the field
        if self.{{name}} is None and "{{{name}}}" in self.model_fields_set:
            _dict['{{{baseName}}}'] = None

        {{/isNullable}}
        {{/allVars}}
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance from a dict"""
        if obj is None:
            return None
        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        base_obj = super().from_dict(obj)

        extra_fields = cls.model_validate({
            {{#vendorExtensions.x-localVars}}
            {{#isContainer}}
            {{#isArray}}
            {{#items.isArray}}
            {{#items.items.isPrimitiveType}}
            "{{{baseName}}}": obj.get("{{{baseName}}}"){{^-last}},{{/-last}}
            {{/items.items.isPrimitiveType}}
            {{^items.items.isPrimitiveType}}
            "{{{baseName}}}": [
                    [{{{items.items.dataType}}}.from_dict(_inner_item) for _inner_item in _item]
                    for _item in obj["{{{baseName}}}"]
                ] if obj.get("{{{baseName}}}") is not None else None{{^-last}},{{/-last}}
            {{/items.items.isPrimitiveType}}
            {{/items.isArray}}
            {{^items.isArray}}
            {{^items.isPrimitiveType}}
            {{#items.isEnumOrRef}}
            "{{{baseName}}}": obj.get("{{{baseName}}}"){{^-last}},{{/-last}}
            {{/items.isEnumOrRef}}
            {{^items.isEnumOrRef}}
            "{{{baseName}}}": [{{{items.dataType}}}.from_dict(_item) for _item in obj["{{{baseName}}}"]] if obj.get("{{{baseName}}}") is not None else None{{^-last}},{{/-last}}
            {{/items.isEnumOrRef}}
            {{/items.isPrimitiveType}}
            {{#items.isPrimitiveType}}
            "{{{baseName}}}": obj.get("{{{baseName}}}"){{^-last}},{{/-last}}
            {{/items.isPrimitiveType}}
            {{/items.isArray}}
            {{/isArray}}
            {{#isMap}}
            {{^items.isPrimitiveType}}
            {{^items.isEnumOrRef}}
            {{#items.isContainer}}
            {{#items.isMap}}
            "{{{baseName}}}": dict(
                (_k, dict(
                    (_ik, {{{items.items.dataType}}}.from_dict(_iv))
                        for _ik, _iv in _v.items()
                    )
                    if _v is not None
                    else None
                )
                for _k, _v in obj.get("{{{baseName}}}").items()
            )
            if obj.get("{{{baseName}}}") is not None
            else None{{^-last}},{{/-last}}
            {{/items.isMap}}
            {{#items.isArray}}
            "{{{baseName}}}": dict(
                (_k,
                        [{{{items.items.dataType}}}.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("{{{baseName}}}", {}).items()
            ){{^-last}},{{/-last}}
            {{/items.isArray}}
            {{/items.isContainer}}
            {{^items.isContainer}}
            "{{{baseName}}}": dict(
                (_k, {{{items.dataType}}}.from_dict(_v))
                for _k, _v in obj["{{{baseName}}}"].items()
            )
            if obj.get("{{{baseName}}}") is not None
            else None{{^-last}},{{/-last}}
            {{/items.isContainer}}
            {{/items.isEnumOrRef}}
            {{#items.isEnumOrRef}}
            "{{{baseName}}}": dict((_k, _v) for _k, _v in obj.get("{{{baseName}}}").items()) if obj.get("{{{baseName}}}") is not None else None{{^-last}},{{/-last}}
            {{/items.isEnumOrRef}}
            {{/items.isPrimitiveType}}
            {{#items.isPrimitiveType}}
            "{{{baseName}}}": obj.get("{{{baseName}}}"){{^-last}},{{/-last}}
            {{/items.isPrimitiveType}}
            {{/isMap}}
            {{/isContainer}}
            {{^isContainer}}
            {{^isPrimitiveType}}
            {{^isEnumOrRef}}
            "{{{baseName}}}": {{{dataType}}}.from_dict(obj["{{{baseName}}}"]) if obj.get("{{{baseName}}}") is not None else None{{^-last}},{{/-last}}
            {{/isEnumOrRef}}
            {{#isEnumOrRef}}
            "{{{baseName}}}": obj.get("{{{baseName}}}"){{#defaultValue}} if obj.get("{{baseName}}") is not None else {{defaultValue}}{{/defaultValue}}{{^-last}},{{/-last}}
            {{/isEnumOrRef}}
            {{/isPrimitiveType}}
            {{#isPrimitiveType}}
            {{#defaultValue}}
            "{{{baseName}}}": obj.get("{{{baseName}}}") if obj.get("{{{baseName}}}") is not None else {{{defaultValue}}}{{^-last}},{{/-last}}
            {{/defaultValue}}
            {{^defaultValue}}
            "{{{baseName}}}": obj.get("{{{baseName}}}"){{^-last}},{{/-last}}
            {{/defaultValue}}
            {{/isPrimitiveType}}
            {{/isContainer}}
            {{/vendorExtensions.x-localVars}}
        })
        return cls(**base_obj.model_dump(), **extra_fields)

// (c) Copyright Ascensio System SIA 2009-2025
//
// This program is a free software product.
// You can redistribute it and/or modify it under the terms
// of the GNU Affero General Public License (AGPL) version 3 as published by the Free Software
// Foundation. In accordance with Section 7(a) of the GNU AGPL its Section 15 shall be amended
// to the effect that Ascensio System SIA expressly excludes the warranty of non-infringement of
// any third-party rights.
//
// This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty
// of MERCHANTABILITY or FITNESS FOR A PARTICULAR  PURPOSE. For details, see
// the GNU AGPL at: http://www.gnu.org/licenses/agpl-3.0.html
//
// You can contact Ascensio System SIA at Lubanas st. 125a-25, Riga, Latvia, EU, LV-1021.
//
// The  interactive user interfaces in modified source and object code versions of the Program must
// display Appropriate Legal Notices, as required under Section 5 of the GNU AGPL version 3.
//
// Pursuant to Section 7(b) of the License you must retain the original Product logo when
// distributing the program. Pursuant to Section 7(e) we decline to grant you any rights under
// trademark law for use of our trademarks.
//
// All the Product's GUI elements, including illustrations and icon sets, as well as technical
// writing
// content are licensed under the terms of the Creative Commons Attribution-ShareAlike 4.0
// International. See the License terms at http://creativecommons.org/licenses/by-sa/4.0/legalcode

package com.asc.common.utilities.crypto;

import java.util.Random;

/**
 * A pseudorandom number generator that extends {@link java.util.Random} using a custom internal
 * algorithm.
 *
 * <p>This implementation maintains an internal state in an array of 56 integers and uses two
 * indices to generate random numbers. It supports generating random integers within a specified
 * bound and random bytes.
 */
class AscRandom extends Random {
  private int inext;
  private int inextp;
  private final int[] seeds;

  /** Constructs a new AscRandom instance using the current system time as the seed. */
  public AscRandom() {
    this((int) System.currentTimeMillis());
  }

  /**
   * Constructs a new AscRandom instance with a specified seed.
   *
   * @param seed the initial seed value
   */
  public AscRandom(int seed) {
    seeds = new int[56];
    var num4 = (seed == Integer.MIN_VALUE) ? Integer.MAX_VALUE : Math.abs(seed);

    var num2 = 161803398 - num4;
    seeds[seeds.length - 1] = num2;

    var num3 = 1;

    for (var i = 1; i < seeds.length - 1; i++) {
      var index = (21 * i) % (seeds.length - 1);
      seeds[index] = num3;
      num3 = num2 - num3;
      if (num3 < 0) num3 += Integer.MAX_VALUE;
      num2 = seeds[index];
    }

    for (var j = 1; j < 5; j++) {
      for (var k = 1; k < seeds.length; k++) {
        seeds[k] -= seeds[1 + ((k + 30) % (seeds.length - 1))];
        if (seeds[k] < 0) seeds[k] += Integer.MAX_VALUE;
      }
    }

    inext = 0;
    inextp = 21;
  }

  /**
   * Returns a pseudorandom, uniformly distributed {@code int} value between 0 (inclusive) and the
   * specified value (exclusive).
   *
   * <p>The random number is generated by scaling the internal sample value.
   *
   * @param maxValue the upper bound (exclusive) for the random number; must be positive
   * @return a pseudorandom {@code int} value between 0 (inclusive) and {@code maxValue} (exclusive)
   * @throws IllegalArgumentException if {@code maxValue} is negative
   */
  public int nextInt(int maxValue) {
    if (maxValue < 0) throw new IllegalArgumentException("maxValue must be positive");
    return (int) (internalSample() * 4.6566128752457969E-10 * maxValue);
  }

  /**
   * Generates random bytes and places them into the provided byte array.
   *
   * <p>The number of random bytes produced is equal to the length of the array.
   *
   * @param buffer the byte array to fill with random bytes
   * @throws NullPointerException if {@code buffer} is null
   */
  public void nextBytes(byte[] buffer) {
    if (buffer == null) throw new NullPointerException("buffer cannot be null");
    for (var i = 0; i < buffer.length; i++) buffer[i] = (byte) (internalSample() % 256);
  }

  /**
   * Generates a new pseudorandom integer using the internal state.
   *
   * <p>This method updates the internal state array using two indices, {@code inext} and {@code
   * inextp}, and produces a new random number based on their difference. The method ensures that
   * the result is always non-negative and does not equal {@code Integer.MAX_VALUE}.
   *
   * @return a pseudorandom integer
   */
  private int internalSample() {
    var inextLocal = inext;
    var inextpLocal = inextp;

    if (++inextLocal >= seeds.length - 1) inextLocal = 1;
    if (++inextpLocal >= seeds.length - 1) inextpLocal = 1;

    var num = seeds[inextLocal] - seeds[inextpLocal];
    if (num == Integer.MAX_VALUE) num--;

    if (num < 0) num += Integer.MAX_VALUE;

    seeds[inextLocal] = num;
    inext = inextLocal;
    inextp = inextpLocal;

    return num;
  }
}
